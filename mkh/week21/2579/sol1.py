n = int(input())
# 각 계단의 점수를 리스트로 저장
stairs = [int(input()) for _ in range(n)]

# dp0: 현재 계단에 '두 계단 점프'로 도달한 경우의 최대 점수
# dp1: 현재 계단에 '한 계단 점프'로 도달한 경우의 최대 점수
# (연속 세 계단을 방지하기 위해 두 경우를 분리)
dp0 = [0]*(n+1)
dp1 = [0]*(n+1)

# 초기값 설정
# 첫 번째 계단은 두 계단 점프로 올 수 없으므로 dp0에만 값 설정
dp0[1] = stairs[0]

# 두 번째 계단의 경우 두 계단 점프로만 도달 가능
# n=1인 경우를 위해 try-except 사용
try:
    dp0[2] = stairs[1]
except:
    pass

for i in range(1, n+1):
    # 현재 위치에서 한 계단 더 갈 수 있는 경우
    if dp0[i] and i+1 <= n:
        # dp0[i]에서 한 계단 올라가는 경우
        # (두 계단 점프 후 한 계단 점프는 가능)
        dp1[i+1] = dp0[i] + stairs[i]
    
    # 현재 위치에서 두 계단 더 갈 수 있는 경우
    if i+2 <= n:
        # dp0[i]: 이전에 두 계단 점프로 온 경우
        # dp1[i]: 이전에 한 계단 점프로 온 경우
        # 둘 중 큰 값에 새로운 계단 값을 더함
        dp0[i+2] = max(dp0[i], dp1[i]) + stairs[i+1]

# 마지막 계단에 도달하는 두 가지 경우(한 계단 또는 두 계단 점프) 중 최댓값
print(max(dp0[n], dp1[n]))
