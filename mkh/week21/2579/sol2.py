# 계단의 개수 입력
n = int(input())
# 각 계단의 점수를 리스트로 저장
stairs = [int(input()) for _ in range(n)]

# 계단이 1개인 경우는 특별히 처리
# (첫 번째 계단의 점수가 곧 정답)
if n == 1:
    print(stairs[0])
else:
    # dp0: 현재 계단에 '두 계단 점프'로 도달한 경우의 최대 점수
    # dp1: 현재 계단에 '한 계단 점프'로 도달한 경우의 최대 점수
    dp0 = [0]*(n+1)
    dp1 = [0]*(n+1)

    # 초기값 설정
    # dp0[1]: 첫 번째 계단의 점수
    dp0[1] = stairs[0]
    # dp0[2]: 두 번째 계단의 점수 (두 계단 점프로 도달)
    dp0[2] = stairs[1]

    for i in range(1, n+1):
        # 현재 위치(i)에서 한 계단 더 올라갈 수 있는 경우
        if i+1 <= n:
            # 이전에 두 계단 점프로 온 상태(dp0[i])에서
            # 한 계단 더 올라가는 경우의 점수를 계산
            # (두 계단 점프 후 한 계단 점프는 가능)
            dp1[i+1] = dp0[i] + stairs[i]
        
        # 현재 위치(i)에서 두 계단 더 올라갈 수 있는 경우
        if i+2 <= n:
            # 현재 위치까지의 최대 점수(dp0[i]와 dp1[i] 중 큰 값)에
            # 두 계단 앞의 계단 점수를 더함
            # dp0[i]: 이전에 두 계단 점프로 온 경우
            # dp1[i]: 이전에 한 계단 점프로 온 경우
            dp0[i+2] = max(dp0[i], dp1[i]) + stairs[i+1]

    # 마지막 계단에 도달하는 두 가지 경우 중 최댓값을 출력
    # dp0[n]: 마지막 계단을 두 계단 점프로 도달한 경우
    # dp1[n]: 마지막 계단을 한 계단 점프로 도달한 경우
    print(max(dp0[n], dp1[n]))